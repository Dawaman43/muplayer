{"$message_type":"diagnostic","message":"unused import: `ListBox`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main_playable.rs","byte_start":99,"byte_end":106,"line_start":2,"line_end":2,"column_start":78,"column_end":85,"is_primary":true,"text":[{"text":"use gtk4::{ApplicationWindow, Button, Label, Box, Scale, Orientation, Frame, ListBox, TreeView, TreeViewColumn, TreeStore, CellRendererText, ScrolledWindow, Grid, Separator, FileChooserAction, FileChooserDialog};","highlight_start":78,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":97,"byte_end":106,"line_start":2,"line_end":2,"column_start":76,"column_end":85,"is_primary":true,"text":[{"text":"use gtk4::{ApplicationWindow, Button, Label, Box, Scale, Orientation, Frame, ListBox, TreeView, TreeViewColumn, TreeStore, CellRendererText, ScrolledWindow, Grid, Separator, FileChooserAction, FileChooserDialog};","highlight_start":76,"highlight_end":85}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ListBox`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:2:78\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use gtk4::{ApplicationWindow, Button, Label, Box, Scale, Orientation, Frame, ListBox, TreeView, TreeViewColumn, TreeStore, CellRendererTe\u001b[1m\u001b[94m...\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                                                                              \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":9926,"byte_end":9932,"line_start":310,"line_end":310,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":48,"highlight_end":54}],"label":"the trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `AsRef<T>`:\n  `gtk4::Label` implements `AsRef<Accessible>`\n  `gtk4::Label` implements `AsRef<Buildable>`\n  `gtk4::Label` implements `AsRef<ConstraintTarget>`\n  `gtk4::Label` implements `AsRef<ObjectRef>`\n  `gtk4::Label` implements `AsRef<gtk4::Label>`\n  `gtk4::Label` implements `AsRef<gtk4::Widget>`\n  `gtk4::Label` implements `AsRef<gtk4::glib::Object>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:310:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_name.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `AsRef<T>`:\n              `gtk4::Label` implements `AsRef<Accessible>`\n              `gtk4::Label` implements `AsRef<Buildable>`\n              `gtk4::Label` implements `AsRef<ConstraintTarget>`\n              `gtk4::Label` implements `AsRef<ObjectRef>`\n              `gtk4::Label` implements `AsRef<gtk4::Label>`\n              `gtk4::Label` implements `AsRef<gtk4::Widget>`\n              `gtk4::Label` implements `AsRef<gtk4::glib::Object>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":9953,"byte_end":9958,"line_start":311,"line_end":311,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                label.set_text(&song.title);","highlight_start":17,"highlight_end":22}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main_playable.rs","byte_start":9926,"byte_end":9932,"line_start":310,"line_end":310,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":48,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":9912,"byte_end":9912,"line_start":310,"line_end":310,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main_playable.rs","byte_start":9925,"byte_end":9934,"line_start":310,"line_end":310,"column_start":47,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":47,"highlight_end":56}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:310:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_name.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 label.set_text(&song.title);\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: try using a fully qualified path to specify the expected types\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[91m- \u001b[0m            if let Some(label) = np_track_name\u001b[91m.as_ref()\u001b[0m {\n\u001b[1m\u001b[94m310\u001b[0m \u001b[92m+ \u001b[0m            if let Some(label) = \u001b[92m<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&\u001b[0mnp_track_name\u001b[92m)\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10045,"byte_end":10051,"line_start":313,"line_end":313,"column_start":50,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":50,"highlight_end":56}],"label":"the trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `AsRef<T>`:\n  `gtk4::Label` implements `AsRef<Accessible>`\n  `gtk4::Label` implements `AsRef<Buildable>`\n  `gtk4::Label` implements `AsRef<ConstraintTarget>`\n  `gtk4::Label` implements `AsRef<ObjectRef>`\n  `gtk4::Label` implements `AsRef<gtk4::Label>`\n  `gtk4::Label` implements `AsRef<gtk4::Widget>`\n  `gtk4::Label` implements `AsRef<gtk4::glib::Object>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:313:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m313\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_artist.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `AsRef<T>`:\n              `gtk4::Label` implements `AsRef<Accessible>`\n              `gtk4::Label` implements `AsRef<Buildable>`\n              `gtk4::Label` implements `AsRef<ConstraintTarget>`\n              `gtk4::Label` implements `AsRef<ObjectRef>`\n              `gtk4::Label` implements `AsRef<gtk4::Label>`\n              `gtk4::Label` implements `AsRef<gtk4::Widget>`\n              `gtk4::Label` implements `AsRef<gtk4::glib::Object>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10072,"byte_end":10077,"line_start":314,"line_end":314,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                label.set_text(&song.artist);","highlight_start":17,"highlight_end":22}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main_playable.rs","byte_start":10045,"byte_end":10051,"line_start":313,"line_end":313,"column_start":50,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":50,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":10029,"byte_end":10029,"line_start":313,"line_end":313,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main_playable.rs","byte_start":10044,"byte_end":10053,"line_start":313,"line_end":313,"column_start":49,"column_end":58,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":49,"highlight_end":58}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:313:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m313\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_artist.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\u001b[1m\u001b[94m314\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 label.set_text(&song.artist);\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: try using a fully qualified path to specify the expected types\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m313\u001b[0m \u001b[91m- \u001b[0m            if let Some(label) = np_track_artist\u001b[91m.as_ref()\u001b[0m {\n\u001b[1m\u001b[94m313\u001b[0m \u001b[92m+ \u001b[0m            if let Some(label) = \u001b[92m<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&\u001b[0mnp_track_artist\u001b[92m)\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10639,"byte_end":10645,"line_start":330,"line_end":330,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":48,"highlight_end":54}],"label":"the trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `AsRef<T>`:\n  `gtk4::Label` implements `AsRef<Accessible>`\n  `gtk4::Label` implements `AsRef<Buildable>`\n  `gtk4::Label` implements `AsRef<ConstraintTarget>`\n  `gtk4::Label` implements `AsRef<ObjectRef>`\n  `gtk4::Label` implements `AsRef<gtk4::Label>`\n  `gtk4::Label` implements `AsRef<gtk4::Widget>`\n  `gtk4::Label` implements `AsRef<gtk4::glib::Object>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:330:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_name.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `AsRef<T>`:\n              `gtk4::Label` implements `AsRef<Accessible>`\n              `gtk4::Label` implements `AsRef<Buildable>`\n              `gtk4::Label` implements `AsRef<ConstraintTarget>`\n              `gtk4::Label` implements `AsRef<ObjectRef>`\n              `gtk4::Label` implements `AsRef<gtk4::Label>`\n              `gtk4::Label` implements `AsRef<gtk4::Widget>`\n              `gtk4::Label` implements `AsRef<gtk4::glib::Object>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10666,"byte_end":10671,"line_start":331,"line_end":331,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                label.set_text(&song.title);","highlight_start":17,"highlight_end":22}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main_playable.rs","byte_start":10639,"byte_end":10645,"line_start":330,"line_end":330,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":48,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":10625,"byte_end":10625,"line_start":330,"line_end":330,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main_playable.rs","byte_start":10638,"byte_end":10647,"line_start":330,"line_end":330,"column_start":47,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_name.as_ref() {","highlight_start":47,"highlight_end":56}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:330:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_name.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\u001b[1m\u001b[94m331\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 label.set_text(&song.title);\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: try using a fully qualified path to specify the expected types\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[91m- \u001b[0m            if let Some(label) = np_track_name\u001b[91m.as_ref()\u001b[0m {\n\u001b[1m\u001b[94m330\u001b[0m \u001b[92m+ \u001b[0m            if let Some(label) = \u001b[92m<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&\u001b[0mnp_track_name\u001b[92m)\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10758,"byte_end":10764,"line_start":333,"line_end":333,"column_start":50,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":50,"highlight_end":56}],"label":"the trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `AsRef<T>`:\n  `gtk4::Label` implements `AsRef<Accessible>`\n  `gtk4::Label` implements `AsRef<Buildable>`\n  `gtk4::Label` implements `AsRef<ConstraintTarget>`\n  `gtk4::Label` implements `AsRef<ObjectRef>`\n  `gtk4::Label` implements `AsRef<gtk4::Label>`\n  `gtk4::Label` implements `AsRef<gtk4::Widget>`\n  `gtk4::Label` implements `AsRef<gtk4::glib::Object>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `gtk4::Label: AsRef<std::option::Option<_>>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:333:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m333\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_artist.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `AsRef<std::option::Option<_>>` is not implemented for `gtk4::Label`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `AsRef<T>`:\n              `gtk4::Label` implements `AsRef<Accessible>`\n              `gtk4::Label` implements `AsRef<Buildable>`\n              `gtk4::Label` implements `AsRef<ConstraintTarget>`\n              `gtk4::Label` implements `AsRef<ObjectRef>`\n              `gtk4::Label` implements `AsRef<gtk4::Label>`\n              `gtk4::Label` implements `AsRef<gtk4::Widget>`\n              `gtk4::Label` implements `AsRef<gtk4::glib::Object>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main_playable.rs","byte_start":10785,"byte_end":10790,"line_start":334,"line_end":334,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                label.set_text(&song.artist);","highlight_start":17,"highlight_end":22}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main_playable.rs","byte_start":10758,"byte_end":10764,"line_start":333,"line_end":333,"column_start":50,"column_end":56,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":50,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":10742,"byte_end":10742,"line_start":333,"line_end":333,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main_playable.rs","byte_start":10757,"byte_end":10766,"line_start":333,"line_end":333,"column_start":49,"column_end":58,"is_primary":true,"text":[{"text":"            if let Some(label) = np_track_artist.as_ref() {","highlight_start":49,"highlight_end":58}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:333:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m333\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(label) = np_track_artist.as_ref() {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 label.set_text(&song.artist);\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: try using a fully qualified path to specify the expected types\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m333\u001b[0m \u001b[91m- \u001b[0m            if let Some(label) = np_track_artist\u001b[91m.as_ref()\u001b[0m {\n\u001b[1m\u001b[94m333\u001b[0m \u001b[92m+ \u001b[0m            if let Some(label) = \u001b[92m<gtk4::Label as AsRef<std::option::Option<T>>>::as_ref(&\u001b[0mnp_track_artist\u001b[92m)\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `stream_handle`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main_playable.rs","byte_start":2783,"byte_end":2800,"line_start":92,"line_end":92,"column_start":25,"column_end":42,"is_primary":true,"text":[{"text":"        if let Some((_, ref stream_handle)) = self.stream_handle {","highlight_start":25,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":2783,"byte_end":2800,"line_start":92,"line_end":92,"column_start":25,"column_end":42,"is_primary":true,"text":[{"text":"        if let Some((_, ref stream_handle)) = self.stream_handle {","highlight_start":25,"highlight_end":42}],"label":null,"suggested_replacement":"_stream_handle","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `stream_handle`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:92:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some((_, ref stream_handle)) = self.stream_handle {\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_stream_handle`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `stream_handle`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main_playable.rs","byte_start":30706,"byte_end":30723,"line_start":881,"line_end":881,"column_start":25,"column_end":42,"is_primary":true,"text":[{"text":"        if let Some((_, ref stream_handle)) = state.stream_handle {","highlight_start":25,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":30706,"byte_end":30723,"line_start":881,"line_end":881,"column_start":25,"column_end":42,"is_primary":true,"text":[{"text":"        if let Some((_, ref stream_handle)) = state.stream_handle {","highlight_start":25,"highlight_end":42}],"label":null,"suggested_replacement":"_stream_handle","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `stream_handle`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:881:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m881\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some((_, ref stream_handle)) = state.stream_handle {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_stream_handle`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `controls_box`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main_playable.rs","byte_start":33563,"byte_end":33575,"line_start":969,"line_end":969,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"    let controls_box = Box::builder()","highlight_start":9,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main_playable.rs","byte_start":33563,"byte_end":33575,"line_start":969,"line_end":969,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"    let controls_box = Box::builder()","highlight_start":9,"highlight_end":21}],"label":null,"suggested_replacement":"_controls_box","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `controls_box`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main_playable.rs:969:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m969\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let controls_box = Box::builder()\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_controls_box`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 8 previous errors; 4 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 8 previous errors; 4 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
